printPh(areacode, 3dig, 4dig, countrycode) {


}

updatePh(areacode, 3dig, 4dig, countrycode) {

}

struct {
    areacode, 3dig, 4dig, countrycode
}

printPh(struct ph) {


}

updatePh(struct ph) {

}

class contactable {}

class Ph : contactable {
   areacode, 3dig, 4dig, countrycode
   print();
   update();
}



vector<byte> ph;

dial(ph, contry src, contry dest) {

}


contact(type, ph) {

}



immutability


scoping approach that doesn't force context....


decoupling


ITyped {
   long asLong();
   int> asInt();
}




var x = 5000.53;
var y = "string";



5.000,53
5,000.00


x.asStr();
y.asLong;


var q = Money(
    "USD",
   x
)


var ww = LenUnit(
"feet",
x
)

// z isn't the invoked result
// z is a datastructure
var z = NationalizedMoney(
  "usa",
  Mult(a, RESTLOOKOKUP("VNT", "USA"))
)

evalStr(z); // $45.00

evalStrSticky(z);

evalStr(z); // invokes and frees z

function() {


  var z =

}


C#
javascript





Scale = Map

var add = function(x,y) { return x + y;}

add(3,4);




no recursive paths in the datastructure for memory



no graphs - tree structure


array[things]

Things
  WatchThings
    Watch

  Add
    Add
      Locate("age")
      4
    Locate("age")
  Age
    34
  Pool(
    UseWatched("PoolSize", "resize"),
    PoolThing
      NationalizedMoney(
        "usa",
        Mult(a, RESTLOOKOKUP("VNT", "USA"))
      )
    "MyPVChanged"
  )


Pool
  -- Provide a reusable resource
  -- Allocate memory for reusable resources


Locate[theThing]

fragmentation


RUST
????
int add(int x, int y) { return x + y; }
